import 'dart:async';  
// 비동기 라이브러리 사용(시간이 오래 걸리는 작업설정 후 작업완료와 상관없이 값을 반환)

void main() {
  startPomodoroTimer();  // Pomodoro 타이머를 시작
}

void startPomodoroTimer() {
  int cycleCount = 0;  // 전체 Pomodoro 타이머의 회차를 초기화
  int sessionCount = 0;  // 세션 카운트를 초기화
  const workDuration = Duration(minutes: 25);  // 작업 시간을 설정
  const shortBreakDuration = Duration(minutes: 5);  // 짧은 휴식 시간을 설정
  const longBreakDuration = Duration(minutes: 15);  // 긴 휴식 시간을 설정

  // Timer.periodic을 사용하여 반복 타이머를 생성
  Timer timer = Timer.periodic(Duration(seconds: 1), (timer) {
    if (sessionCount < 4) {  // 4회차 이전이라면
      print('작업 시간: ${workDuration.inMinutes}분');
      Future.delayed(workDuration, () {
        print('휴식 시간: ${shortBreakDuration.inMinutes}분');
      });
    } else {  // 4회차라면
      print('작업 시간: ${workDuration.inMinutes}분');
      Future.delayed(workDuration, () {
        print('긴 휴식 시간: ${longBreakDuration.inMinutes}분');
      });
      sessionCount = 0;  // 회차를 초기화
      cycleCount++;  // 전체 Pomodoro 타이머의 회차를 증가
    }
    sessionCount++;
    if (cycleCount == 8) {  // 전체 Pomodoro 타이머가 8회차를 반복하면
      timer.cancel();  // 타이머를 취소
    }
  });
}

//분석: 
//1. 작업 시간과 휴식 시간이 올바르게 번갈아 가며 출력되지 않는 문제가 발생
//2. 이 문제는 Future.delayed 함수 내부에서 sessionCount++를 호출하기에 발생
//3. 문제해결을 위해 sessionCount++를 Future.delayed 함수 외부로 이동
//4. startPomodoroTimer 함수를 사용하여 하나의 함수 내에 필요한 로직을 구현

//회고B:
//배운 점: dart:async 라이브러리와 Timer.periodic 함수를 사용하여 반복 타이머를 구현하는 방법을 배웠고 Future.delayed 함수를 사용하여 작업 시간과 휴식 시간을 설정하는 방법을 배웠다.
//아쉬운 점: 처음에는 작업 시간과 휴식 시간이 올바르게 번갈아 가며 출력되지 않는 문제가 있었는데 이 문제는 Future.delayed 함수 내부에서 sessionCount++를 호출하고 있어서 발행한 것을 확인했고 이 문제를 해결하기 위해 sessionCount++를 Future.delayed 함수 외부로 이동시켰다.
//느낀 점: 이 프로젝트를 통해 Dart 언어의 비동기 프로그래밍 기능을 활용하는 방법을 배울 수 있었는데 이것은 특히 시간이 오래 걸리는 작업을 처리할 때 유용하다는 것을 알게 되었다.

